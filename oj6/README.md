# oj6
6th oj for data and algorithm
### 问题描述
小明拥有n盏小灯（1≤n≤1000），记其状态为b=[b0, b1, ..., bn-1]。每盏灯只有2种可能状态：bi=1（亮）、bi=0（灭），初始状态为全灭。为了控制这n盏小灯，小明手上有2个按钮：A和B。按下按钮A会将小灯的状态循环向右流动（右移）1个单位：[b0, b1, ..., bn-1]→[bn-1, b0, b1, ..., bn-2]；按钮B会将指定位置的小灯状态进行翻转：例如按钮B被按下时，会翻转序号为S={1, 3, 5}位置的小灯，集合S会在输入数据中给出。
 
现在给定某一种n盏小灯的亮灭状态t=[t0, t1, ..., tn-1]，问小明是否可以通过操作按钮A和B来将初始状态全灭的小灯调节至目标状态t？如果可以，输出任意1种可行的操作序列（至少包含1个操作，由AB两种或一种字符构成字符串以代表操作序列）；如果不可以，输出字符N。
### 输入格式
输入数据的第0行是一个正整数M，表示后续数据的行数。M不超过10。  
输入数据的第1~M行，每一行由3个数构成，从而指定1个“流光溢彩”问题：  
    (0) 第0个数为题目中的n。   
    (1) 第1个数为一个长度为n的0/1比特串，代表集合S。例如：n=5时，00101代表集合S={2, 4}。  
    (2) 第2个数为一个长度为n的0/1比特串，代表目标状态t=[t0, t1, ..., tn-1]。  
 
注意：在一个测试点中，我们需要解M个“流光溢彩”问题。
### 输出格式
输出数据为M行，第i行（0≤i<M）代表第i个“流光溢彩”问题的解。它要么是{A, B}构成的字符串，例如ABAAB；要么是N。
### 输入样例
    5
    32 11011111100100101001101110111000     10110100000100110110101101101000
    32 01100000011001111101011000100101     10000000000101000000100010100011
    32 10010010111000001101001111110010     10100111101110001000111011001010
    32 11001111010000111000000001100110     01101010010000111011110011000111
    32 10100100111010100100111110011110     10110110010000001001111010101010
### 输出样例
    BABABAAABABAABABAABAAABAABABAABAAABABABAAAAABABA
    BAABAAAABABAAAABAAAABAAABABAAABAABABAABABABAA
    N
    N
    N
### 提示
(1) 简单算法设计：采用long long (8 byte, 64 bit)数据类型来存储小灯状态，并使用双向广度优先搜索（BFS）算法来寻找从全灭状态（0）到达目标状态（t）的一条可行路径。前向BFS树从0状态出发，反向BFS树从t状态出发。每次访问过一个状态以后，使用哈希表存储这个状态以及它的前一个状态的信息。当双向BFS结点相遇时，采用回溯的方法来得到整个从0到t状态所需要的操作序列。我们保证此种暴力算法能通过7个测试点。  
Notes: 第10个测试点n=1000，但是其余测试点的n值均＜=64.
 
(2) 复杂度上界：事实上，可以证明：对于规模为n的“流光溢彩”问题，无论集合S和目标状态t是什么，只要存在解，那么所需要的最少按钮操作次数不超过2n。
 
(3) 更深的数学结构：实际上，所有小灯的状态构成线性空间V。因此，判定状态t是否可达就相当于判定元素t是否∈V；寻找一条操作路径就相当于寻找线性空间V的基底，以及元素t在基底下的分解。对于判定t是否∈V的问题，我们可以寻找V的正交补空间V'，然后判定t是否与V'垂直。当然也可以利用线性代数中的解线性方程组的方法。
 
(4) 对于寻找路径问题，可以利用线性方程组的解来直接决定每一步的操作应该为A还是为B。如果线性方程组无解，就可以直接输出N。
 
(5) 利用循环对称性条件来降低算法复杂度：可以利用循环对称矩阵的性质来简化算法设计，也可以引入小灯状态的多项式表示，用系数0/1的多项式加法和多项式乘法来表示小灯的翻转和循环移位。请各位同学开动脑筋，尽显才华。
 
(6) 本次OJ是难度较大的OJ之一，但是难度主要集中于最后一个测例。
